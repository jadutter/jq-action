name: 'GitHub-CI: valid image'

on:
  push:
    branches:
      - develop
      - release
  pull_request: {}
  # execute these tests on every branch, to confirm the branch's HEAD can be used as a github action
env:
  sample_data: |
    {
      "types": {
        "null": null,
        "boolean": false,
        "number": 123,
        "strings": {
          "single": "lorem",
          "cost": "$1.99",
          "percentage": "99.99% complete",
          "multiline": "Task:\n\t100% complete"
        },
        "array": [],
        "object": {}
      }
    }
jobs:
  # confirm we know how to properly escape the data that goes into output variables
  job-test-workflow-syntax:
    env:
      sample_var_0: '9'
      sample_var_1: |
        [
          \"types\",
          \"number\"
          ]
        [
          \"types\",
          \"strings\",
          \"single\"
          ]
        [
          \"types\",
          \"strings\",
          \"cost\"
          ]
        [
          \"types\",
          \"strings\",
          \"percentage\"
          ]
        [
          \"types\",
          \"strings\",
          \"multiline\"
        ]

      sample_var_2: |
        {\"types\":{\"null\":null,\"boolean\":false,\"number\":123,\"strings\":{\"single\":\"lorem\",\"cost\":\"$1.99\"}
      sample_var_3: |
        {
          \"types\": {
            \"null\": null,
            \"boolean\": false,
            \"number\": 123,
            \"strings\": {
              \"single\": \"lorem\",
              \"cost\": \"$1.99\",
              \"percentage\": \"99.99% complete\",
              \"multiline\": \"Task:\n          100% complete\"
            },
            \"array\": [],
            \"object\": {}
          },
          \"array\": [
            null,
            false,
            123,
            {
              \"single\": \"lorem\",
              \"cost\": \"$1.99\",
              \"percentage\": \"99.99% complete\",
              \"multiline\": \"Task:\n\t100% complete\"
            },
            [],
            {}
          ]
        }
    runs-on: ubuntu-latest
    steps:
      - name: Manually set variables
        id: manual-vars
        run: >
          sample_var_0="${{ env.sample_var_0 }}"
          sample_var_1="${{ env.sample_var_1 }}"
          sample_var_2="${{ env.sample_var_2 }}"
          sample_var_3="${{ env.sample_var_3 }}"

          echo "declared variables";
          {
            echo 'sample_var_0<<EOF'
            echo "${sample_var_0}" | sed -E 's/"/\\"/g'
            echo EOF
          } >> $GITHUB_OUTPUT;
          {
            echo 'sample_var_1<<EOF'
            echo "${sample_var_1}" | sed -E 's/"/\\"/g'
            echo EOF
          } >> $GITHUB_OUTPUT;
          {
            echo 'sample_var_2<<EOF'
            echo "${sample_var_2}" | sed -E 's/"/\\"/g'
            echo EOF
          } >> $GITHUB_OUTPUT;
          {
            echo 'sample_var_3<<EOF'
            echo "${sample_var_3}" | sed -E 's/"/\\"/g'
            echo EOF
          } >> $GITHUB_OUTPUT;

      - name: Check variables
        run: >
          echo -e "${{ env.sample_var_0 }}" >/tmp/sample_var_0.txt;
          echo -e "${{ env.sample_var_1 }}" >/tmp/sample_var_1.txt;
          echo -e "${{ env.sample_var_2 }}" >/tmp/sample_var_2.txt;
          echo -e "${{ env.sample_var_3 }}" >/tmp/sample_var_3.txt;

          echo -e "${{ steps.manual-vars.outputs.sample_var_0 }}" >/tmp/manual_sample_var_0.txt;
          echo -e "${{ steps.manual-vars.outputs.sample_var_1 }}" >/tmp/manual_sample_var_1.txt;
          echo -e "${{ steps.manual-vars.outputs.sample_var_2 }}" >/tmp/manual_sample_var_2.txt;
          echo -e "${{ steps.manual-vars.outputs.sample_var_3 }}" >/tmp/manual_sample_var_3.txt;

          git diff --no-index /tmp/sample_var_0.txt /tmp/manual_sample_var_0.txt;
          git diff --no-index /tmp/sample_var_1.txt /tmp/manual_sample_var_1.txt;
          git diff --no-index /tmp/sample_var_2.txt /tmp/manual_sample_var_2.txt;
          git diff --no-index /tmp/sample_var_3.txt /tmp/manual_sample_var_3.txt;

  # confirm the docker environment we're creating for the action looks the way we expect it to look
  job-test-env:
    needs: [job-test-workflow-syntax]
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Commit info
        run: >
          echo "hash=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT;
          echo "name=$(git rev-parse --abbrev-ref HEAD)" >> $GITHUB_OUTPUT;

      - name: Validate entrypoint
        uses: jadutter/jq-action@hotfix/patch-action
        id: valid-entrypoint
        with:
          cmd: >
            if [ ! -f '/entrypoint.sh' ]; then
              echo "forgot to add entrypoint.sh" >&2
              exit 1
            elif [ ! -x '/entrypoint.sh' ]; then
              echo "forgot to make entrypoint.sh executable" >&2
              exit 2
            fi;
            echo "entrypoint is valid"

      - name: Get jq version
        uses: jadutter/jq-action@hotfix/patch-action
        id: version
        with:
          cmd: 'jq --version'

      - name: Check version
        run: >
          jq_version="$(echo "${{ steps.version.outputs.stdout }}" | egrep -o 'jq-.+' )";
          if [[ "${#jq_version}" -gt 3 ]]; then
            echo "jq version is '${jq_version}'"
          else
            echo "stdout:"
            echo "${{ steps.version.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.version.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.version.outputs.exit_code }}"
            exit 1
          fi

  # confirm the action itself can be used as expected
  job-test-action:
    needs: [job-test-workflow-syntax, job-test-env]
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: use jq
        uses: jadutter/jq-action@hotfix/patch-action
        id: test-use-jq
        with:
          cmd: 'jq -cn "{foo:\"bar\"} | [.foo]" '

      - name: Check usage
        run: >
          if [[ ! "${{ steps.test-use-jq.outputs.stdout }}" == "[\"bar\"]" ]]; then 
            echo "stdout:"
            echo "${{ steps.test-use-jq.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.test-use-jq.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.test-use-jq.outputs.exit_code }}"
            exit 1
          fi

      - name: multi-line command
        uses: jadutter/jq-action@hotfix/patch-action
        id: test-use-jq-multi-line
        with:
          # use YAML folded style for multi-line command
          cmd: >
            echo '{"foo":"bar"}' | 
            jq '.foo == "bar"'

      - name: Check multiline usage
        run: >
          if [[ "$( echo "${{ steps.test-use-jq-multi-line.outputs.stdout }}" )" != "$(echo "true" )" ]]; then 
            echo "stdout:"
            echo "${{ steps.test-use-jq-multi-line.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.test-use-jq-multi-line.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.test-use-jq-multi-line.outputs.exit_code }}"
            exit 1
          fi

      - name: multi-line input and output
        uses: jadutter/jq-action@hotfix/patch-action
        id: test-use-jq-multi-input-output
        with:
          cmd: >
            jq -n '{
              types: {
                null: null,
                boolean: false,
                number: 123,
                strings: {
                  single: "lorem",
                  cost: "$1.99",
                  percentage: "99.99% complete",
                  multiline: "Task:\n\t100% complete"
                },
                array: [],
                object: {}
              }
            }' | 
            jq -r '
                [
                    {
                        types: .types,
                        array: (
                            .types | to_entries | map(.value)
                        )
                    },
                    getpath(["types", "strings", "multiline"])
                ] | .[]
            '

      - name: Check multiline input and output usage
        run: >
          echo -e "$( echo "{\n  \"types\": {\n    \"null\": null,\n    \"boolean\": false,\n    \"number\": 123,\n    \"strings\": {\n      \"single\": \"lorem\",\n      \"cost\": \"\$1.99\",\n      \"percentage\": \"99.99% complete\",\n      \"multiline\": \"Task:\n\t100% complete\"\n    },\n    \"array\": [],\n    \"object\": {}\n  },\n  \"array\": [\n    null,\n    false,\n    123,\n    {\n      \"single\": \"lorem\",\n      \"cost\": \"\$1.99\",\n      \"percentage\": \"99.99% complete\",\n      \"multiline\": \"Task:\\n\\t100% complete\"\n    },\n    [],\n    {}\n  ]\n}\nTask:\n\t100% complete" )" >/tmp/expected.txt
          echo -e "${{ steps.test-use-jq-multi-input-output.outputs.stdout }}" >/tmp/received.txt
          git diff --no-index /tmp/expected.txt /tmp/received.txt;

      - name: Check manual variables
        uses: jadutter/jq-action@hotfix/patch-action
        id: manual-vars-jq
        with:
          cmd: >
            sample_data=' {
              "types": {
                "null": null,
                "boolean": false,
                "number": 123,
                "strings": {
                  "single": "lorem",
                  "cost": "$1.99",
                  "percentage": "99.99% complete",
                  "multiline": "Task:\n\t100% complete"
                },
                "array": [],
                "object": {}
              }
            }';
            echo "declared sample_data='${sample_data}'";

            var_0="$( jq -n "${sample_data}" | jq 'paths | length' )";
            echo "declared var_0='${var_0}'";
            {
              echo 'var_0<<EOF'
              echo "${var_0}" | sed -E 's/"/\\"/g'
              echo "EOF"
            } >> $GITHUB_OUTPUT;
            echo "set var_0";

            var_1="$( jq -n "${sample_data}" | jq 'paths' )";
            echo "declared var_1='${var_1}'";
            {
              echo 'var_1<<EOF'
              echo "${var_1}" | sed -E 's/"/\\"/g'
              echo "EOF"
            } >> $GITHUB_OUTPUT;
            echo "set var_1";

            var_2="$( jq -n "${sample_data}" | jq 'paths(scalars)' )";
            echo "declared var_2='${var_2}'";
            {
              echo 'var_2<<EOF'
              echo "${var_2}" | sed -E 's/"/\\"/g'
              echo "EOF"
            } >> $GITHUB_OUTPUT;
            echo "set var_2";

            var_3="$( jq -n "${sample_data}" | jq 'to_entries' )";
            echo "declared var_3='${var_3}'";
            {
              echo 'var_3<<EOF'
              echo "${var_3}" | sed -E 's/"/\\"/g'
              echo "EOF"
            } >> $GITHUB_OUTPUT;
            echo "set var_3";

            var_4="$( jq -n "${sample_data}" | jq '.' )";
            echo "declared var_4='${var_4}'";
            {
              echo 'var_4<<EOF'
              echo "${var_4}" | sed -E 's/"/\\"/g'
              echo "EOF"
            } >> $GITHUB_OUTPUT;
            echo "set var_4";

      - name: Show manual variables
        uses: jadutter/jq-action@hotfix/patch-action
        with:
          cmd: >
            sample_data=' {
              "types": {
                "null": null,
                "boolean": false,
                "number": 123,
                "strings": {
                  "single": "lorem",
                  "cost": "$1.99",
                  "percentage": "99.99% complete",
                  "multiline": "Task:\n\t100% complete"
                },
                "array": [],
                "object": {}
              }
            }';
            echo "declared sample_data='${sample_data}'";

            echo "${{ steps.manual-vars-jq.outputs.var_0 }}">/tmp/expected_var_0.txt
            jq -n "${sample_data}" | jq 'paths | length' >/tmp/var_0.txt
            echo "declared var_0='$(cat /tmp/var_0.txt)'";

            echo "${{ steps.manual-vars-jq.outputs.var_0 }}">/tmp/expected_var_1.txt
            jq -n "${sample_data}" | jq 'paths' >/tmp/var_1.txt
            echo "declared var_1='$(cat /tmp/var_1.txt)'";

            echo "${{ steps.manual-vars-jq.outputs.var_0 }}">/tmp/expected_var_2.txt
            jq -n "${sample_data}" | jq 'paths(scalars)' >/tmp/var_2.txt
            echo "declared var_2='$(cat /tmp/var_2.txt)'";

            echo "${{ steps.manual-vars-jq.outputs.var_0 }}">/tmp/expected_var_3.txt
            jq -n "${sample_data}" | jq 'to_entries' >/tmp/var_3.txt
            echo "declared var_3='$(cat /tmp/var_3.txt)'";

            echo "${{ steps.manual-vars-jq.outputs.var_0 }}">/tmp/expected_var_4.txt
            jq -n "${sample_data}" | jq '.' >/tmp/var_4.txt
            echo "declared var_4='$(cat /tmp/var_4.txt)'";

            git diff --no-index /tmp/expected_var_0.txt /tmp/var_0.txt
            git diff --no-index /tmp/expected_var_1.txt /tmp/var_1.txt
            git diff --no-index /tmp/expected_var_2.txt /tmp/var_2.txt
            git diff --no-index /tmp/expected_var_3.txt /tmp/var_3.txt
            git diff --no-index /tmp/expected_var_4.txt /tmp/var_4.txt
