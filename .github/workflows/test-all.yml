name: 'GitHub-CI: valid image'

on:
  push:
    branches:
      - develop
      - release
  pull_request: {}
  # execute these tests on every branch, to confirm the branch's HEAD can be used as a github action
env:
  sample_data: |
    {
      "types": {
        "null": null,
        "boolean": false,
        "number": 123,
        "strings": {
          "single": "lorem",
          "cost": "$1.99",
          "percentage": "99.99% complete",
          "multiline": "Task:\n\t100% complete"
        },
        "array": [],
        "object": {}
      }
    }
jobs:
  # confirm the action itself can be used as expected
  job-test-action:
    needs: [job-test-workflow-syntax, job-test-env]
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: use jq
        uses: jadutter/jq-action@hotfix/patch-action
        id: test-use-jq
        with:
          cmd: 'jq -cn "{foo:\"bar\"} | [.foo]" '

      - name: Check usage
        run: >
          expected='["bar"]';
          if [[ "${{ steps.test-use-jq.outputs.stdout }}" != "${expected}" ]]; then 
            echo "stdout:"
            echo "${{ steps.test-use-jq.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.test-use-jq.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.test-use-jq.outputs.exit_code }}"
            exit 1
          fi

      - name: multi-line command
        uses: jadutter/jq-action@hotfix/patch-action
        id: test-use-jq-multi-line
        with:
          # use YAML folded style for multi-line command
          cmd: >
            echo '{"foo":"bar"}' | 
            jq '.foo == "bar"'

      - name: Check multiline usage
        run: >
          if [[ "$( echo "${{ steps.test-use-jq-multi-line.outputs.stdout }}" )" != "$(echo "true" )" ]]; then 
            echo "stdout:"
            echo "${{ steps.test-use-jq-multi-line.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.test-use-jq-multi-line.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.test-use-jq-multi-line.outputs.exit_code }}"
            exit 1
          fi

      - name: multi-line input and output
        uses: jadutter/jq-action@hotfix/patch-action
        id: test-use-jq-multi-input-output
        with:
          cmd: >
            jq -n '{
              types: {
                null: null,
                boolean: false,
                number: 123,
                strings: {
                  single: "lorem",
                  cost: "$1.99",
                  percentage: "99.99% complete",
                  multiline: "Task:\n\t100% complete"
                },
                array: [],
                object: {}
              }
            }' | 
            jq -r '
                [
                    {
                        types: .types,
                        array: (
                            .types | to_entries | map(.value)
                        )
                    },
                    getpath(["types", "strings", "multiline"])
                ] | .[]
            '

      - name: Check multiline input and output usage
        run: >
          echo -e "$( echo "{\n  \"types\": {\n    \"null\": null,\n    \"boolean\": false,\n    \"number\": 123,\n    \"strings\": {\n      \"single\": \"lorem\",\n      \"cost\": \"\$1.99\",\n      \"percentage\": \"99.99% complete\",\n      \"multiline\": \"Task:\n\t100% complete\"\n    },\n    \"array\": [],\n    \"object\": {}\n  },\n  \"array\": [\n    null,\n    false,\n    123,\n    {\n      \"single\": \"lorem\",\n      \"cost\": \"\$1.99\",\n      \"percentage\": \"99.99% complete\",\n      \"multiline\": \"Task:\\n\\t100% complete\"\n    },\n    [],\n    {}\n  ]\n}\nTask:\n\t100% complete" )" >/tmp/expected.txt
          echo -e "${{ steps.test-use-jq-multi-input-output.outputs.stdout }}" >/tmp/received.txt
          git diff --no-index /tmp/expected.txt /tmp/received.txt;

      - name: Check manual variables
        uses: jadutter/jq-action@hotfix/patch-action
        id: manual-vars-jq
        with:
          cmd: >
            sample_data='{
              "types": {
                "null": null,
                "boolean": false,
                "number": 123,
                "strings": {
                  "single": "lorem",
                  "cost": "$1.99",
                  "percentage": "99.99% complete",
                  "multiline": "Task:\n\t100% complete"
                },
                "array": [],
                "object": {}
              }
            }';
            echo "declared sample_data='${sample_data}'";

            var_0="$( jq -n "${sample_data}" | jq 'paths | length' )";
            echo "declared var_0='${var_0}'";
            {
              echo 'var_0<<EOF'
              echo "${var_0}" | sed -E 's/"/\\"/g'
              echo "EOF"
            } >> $GITHUB_OUTPUT;
            echo "set var_0";

            var_1="$( jq -n "${sample_data}" | jq 'paths' )";
            echo "declared var_1='${var_1}'";
            {
              echo 'var_1<<EOF'
              echo "${var_1}" | sed -E 's/"/\\"/g'
              echo "EOF"
            } >> $GITHUB_OUTPUT;
            echo "set var_1";

            var_2="$( jq -n "${sample_data}" | jq 'paths(scalars)' )";
            echo "declared var_2='${var_2}'";
            {
              echo 'var_2<<EOF'
              echo "${var_2}" | sed -E 's/"/\\"/g'
              echo "EOF"
            } >> $GITHUB_OUTPUT;
            echo "set var_2";

            var_3="$( jq -n "${sample_data}" | jq 'to_entries' )";
            echo "declared var_3='${var_3}'";
            {
              echo 'var_3<<EOF'
              echo "${var_3}" | sed -E 's/"/\\"/g'
              echo "EOF"
            } >> $GITHUB_OUTPUT;
            echo "set var_3";

            var_4="$( jq -n "${sample_data}" | jq '.' )";
            echo "declared var_4='${var_4}'";
            {
              echo 'var_4<<EOF'
              echo "${var_4}" | sed -E 's/"/\\"/g'
              echo "EOF"
            } >> $GITHUB_OUTPUT;
            echo "set var_4";

      - name: Show manual variables
        uses: jadutter/jq-action@hotfix/patch-action
        with:
          cmd: >
            sample_data='{
              "types": {
                "null": null,
                "boolean": false,
                "number": 123,
                "strings": {
                  "single": "lorem",
                  "cost": "$1.99",
                  "percentage": "99.99% complete",
                  "multiline": "Task:\n\t100% complete"
                },
                "array": [],
                "object": {}
              }
            }';
            echo "declared sample_data='${sample_data}'";

            echo "${{ steps.manual-vars-jq.outputs.var_0 }}">/tmp/expected_var_0.txt;
            echo "expecting var_0='$(cat /tmp/expected_var_0.txt)'";
            jq -n "${sample_data}" | jq 'paths | length' >/tmp/var_0.txt;
            echo "declared var_0='$(cat /tmp/var_0.txt)'";

            echo "${{ steps.manual-vars-jq.outputs.var_1 }}">/tmp/expected_var_1.txt;
            echo "expecting var_1='$(cat /tmp/expected_var_1.txt)'";
            jq -n "${sample_data}" | jq 'paths' >/tmp/var_1.txt;
            echo "declared var_1='$(cat /tmp/var_1.txt)'";

            echo "${{ steps.manual-vars-jq.outputs.var_2 }}">/tmp/expected_var_2.txt;
            echo "expecting var_2='$(cat /tmp/expected_var_2.txt)'";
            jq -n "${sample_data}" | jq 'paths(scalars)' >/tmp/var_2.txt;
            echo "declared var_2='$(cat /tmp/var_2.txt)'";

            echo "${{ steps.manual-vars-jq.outputs.var_3 }}">/tmp/expected_var_3.txt;
            echo "expecting var_3='$(cat /tmp/expected_var_3.txt)'";
            jq -n "${sample_data}" | jq 'to_entries' >/tmp/var_3.txt;
            echo "declared var_3='$(cat /tmp/var_3.txt)'";

            echo "${{ steps.manual-vars-jq.outputs.var_4 }}">/tmp/expected_var_4.txt;
            echo "expecting var_4='$(cat /tmp/expected_var_4.txt)'";
            jq -n "${sample_data}" | jq '.' >/tmp/var_4.txt;
            echo "declared var_4='$(cat /tmp/var_4.txt)'";

            git diff --no-index /tmp/expected_var_0.txt /tmp/var_0.txt;
            git diff --no-index /tmp/expected_var_1.txt /tmp/var_1.txt;
            git diff --no-index /tmp/expected_var_2.txt /tmp/var_2.txt;
            git diff --no-index /tmp/expected_var_3.txt /tmp/var_3.txt;
            git diff --no-index /tmp/expected_var_4.txt /tmp/var_4.txt;
