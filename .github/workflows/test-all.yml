name: "GitHub-CI: valid image"

on:
  push: {}
  pull_request: {}
  # execute these tests on every branch, to confirm the branch's HEAD can be used as a github action

jobs:
  test-action:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Show commit hash
        run: 'echo "commit hash is $(git rev-parse HEAD)"'

      - name: valid entrypoint
        uses: jadutter/jq-action@test-workflows
        id: valid-entrypoint
        with:
          cmd: >
            if [ ! -f '/entrypoint.sh' ]; then
              echo "forgot to add entrypoint.sh" >&2
              exit 1
            fi;
            if [ ! -x '/entrypoint.sh' ]; then
              echo "forgot to make entrypoint.sh executable" >&2
              exit 2
            fi;
            echo "entrypoint is valid"

      - name: Get jq version
        uses: jadutter/jq-action@test-workflows
        id: version
        with:
          cmd: "jq --version"

      - name: Show version
        run: 'echo "jq version is ${{ steps.version.outputs.stdout }}"'

      - name: Manually set-output variables
        id: manual-vars
        run: >
          data="$(jq -n '{
              types: {
                null: null,
                boolean: false,
                number: 123,
                strings: {
                  single: "lorem",
                  cost: "$1.99",
                  percentage: "99.99% complete",
                  multiline: "Task:\n\t100% complete"
                },
                array: [],
                object: {}
              }
            }')";
          sed_command='
            :nextLine;
            {
                # add the next line to the pattern space
                N;
            }
            # if not the end of the file
            $!{
                # grab another line
                b nextLine;
            }
            # esape newline characters
            s/\n/%0A/g;
            s/\r/%0D/g;
            # escape characters that would interfere with the `echo ":::set-output...`
            s/("|\\|\$)/\\\1/g;
            # escape percentage sign
            s/%/%25/g;
            # escape whitespace 
            s/  /%09/g;
            s/ /%20/g;
            ';
          var0="$(echo "${data}" | jq 'paths | length' )";
          var1="$(echo "${data}" | jq 'paths' )";
          var2="$(echo "${data}" | jq 'paths(scalars)' )";
          var3="$(echo "${data}" | jq 'to_entries' )";
          var4="$(echo "${data}" | jq )";
          echo "::set-output name=var0::$(echo "${var0}" | sed -E "${sed_command}")"
          echo "::set-output name=var1::$(echo "${var1}" | sed -E "${sed_command}")"
          echo "::set-output name=var2::$(echo "${var2}" | sed -E "${sed_command}")"
          echo "::set-output name=var3::$(echo "${var3}" | sed -E "${sed_command}")"
          echo "::set-output name=var4::$(echo "${var4}" | sed -E "${sed_command}")"

      - name: Check manual set-output
        run: >
          data="$(jq -n '{
              types: {
                null: null,
                boolean: false,
                number: 123,
                strings: {
                  single: "lorem",
                  cost: "$1.99",
                  percentage: "99.99% complete",
                  multiline: "Task:\n\t100% complete"
                },
                array: [],
                object: {}
              }
            }')";
          var0="$(echo "${data}" | jq 'paths | length' )";
          var1="$(echo "${data}" | jq 'paths' )";
          var2="$(echo "${data}" | jq 'paths(scalars)' )";
          var3="$(echo "${data}" | jq 'to_entries' )";
          if [[ "${{ steps.manual-vars.outputs.var0 }}" != "${var0}" ]]; then 
            echo "var0:\n\texpected:'${var0}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var0 }}'"
            exit 1
          fi;
          if [[ "${{ steps.manual-vars.outputs.var1 }}" != "${var1}" ]]; then 
            echo "var1:\n\texpected:'${var1}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var1 }}'"
            exit 1
          fi;
          if [[ "${{ steps.manual-vars.outputs.var2 }}" != "${var2}" ]]; then 
            echo "var2:\n\texpected:'${var2}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var2 }}'"
            exit 1
          fi;
          if [[ "${{ steps.manual-vars.outputs.var3 }}" != "${var3}" ]]; then 
            echo "var3:\n\texpected:'${var3}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var3 }}'"
            exit 1
          fi;
          if [[ "${{ steps.manual-vars.outputs.var4 }}" != "${var4}" ]]; then 
            echo "var4:\n\texpected:'${var4}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var4 }}'"
            exit 1
          fi;

      - name: Check version
        run: >
          if [[ "$(
            echo "${{ steps.version.outputs.stdout }}" |
            egrep -o 'jq-.+' | 
            wc -m )" -lt 4 ]]; then 
            echo "stdout:"
            echo "${{ steps.version.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.version.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.version.outputs.exit_code }}"
            exit 1
          fi

      - name: use jq
        uses: jadutter/jq-action@test-workflows
        id: test-use-jq
        with:
          cmd: 'jq -cn "{foo:\"bar\"} | [.foo]" '

      - name: Check usage
        run: >
          if [[ ! "${{ steps.test-use-jq.outputs.stdout }}" == "[\"bar\"]" ]]; then 
            echo "stdout:"
            echo "${{ steps.test-use-jq.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.test-use-jq.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.test-use-jq.outputs.exit_code }}"
            exit 1
          fi

      - name: multi-line command
        uses: jadutter/jq-action@test-workflows
        id: test-use-jq-multi-line
        with:
          # use YAML folded style for multi-line command
          cmd: >
            echo '{"foo":"bar"}' | 
            jq '.foo == "bar"'

      - name: Check multiline usage
        run: >
          if [[ "${{ steps.test-use-jq-multi-line.outputs.stdout }}" != "true" ]]; then 
            echo "stdout:"
            echo "${{ steps.test-use-jq-multi-line.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.test-use-jq-multi-line.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.test-use-jq-multi-line.outputs.exit_code }}"
            exit 1
          fi

      - name: multi-line input and output
        uses: jadutter/jq-action@test-workflows
        id: test-use-jq-multi-line-output
        with:
          cmd: >
            jq -n '{
              types: {
                null: null,
                boolean: false,
                number: 123,
                strings: {
                  single: "lorem",
                  cost: "$1.99",
                  percentage: "99.99% complete",
                  multiline: "Task:\n\t100% complete"
                },
                array: [],
                object: {}
              }
            }' | 
            jq -r '
                [
                    {
                        types: .types,
                        array: (
                            .types | to_entries | map(.value)
                        )
                    },
                    getpath(["types", "strings", "multiline"])
                ] | .[]
            '

      - name: Check multiline input and output usage
        run: >
          expect='{\n  "types": {\n    "null": null,\n    "boolean": false,\n    "number": 123,\n    "strings": {\n      "single": "lorem",\n      "cost": "$1.99",\n      "percentage": "99.99% complete",\n      "multiline": "Task:\n\t100% complete"\n    },\n    "array": [],\n    "object": {}\n  },\n  "array": [\n    null,\n    false,\n    123,\n    {\n      "single": "lorem",\n      "cost": "$1.99",\n      "percentage": "99.99% complete",\n      "multiline": "Task:\\n\\t100% complete"\n    },\n    [],\n    {}\n  ]\n}\nTask:\n\tt100% complete';
          if [[ "${{ steps.test-use-jq-multi-line-output.outputs.stdout }}" != "$expect" ]]; then 
            echo "stdout:"
            echo "${{ steps.test-use-jq-multi-line-output.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.test-use-jq-multi-line-output.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.test-use-jq-multi-line-output.outputs.exit_code }}"
            exit 1
          fi
