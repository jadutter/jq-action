name: 'GitHub-CI: valid image'

on:
  push:
    branches:
      - develop
      - release
  pull_request: {}
  # execute these tests on every branch, to confirm the branch's HEAD can be used as a github action
env:
  sample_data: |
    {
      "types": {
        "null": null,
        "boolean": false,
        "number": 123,
        "strings": {
          "single": "lorem",
          "cost": "$1.99",
          "percentage": "99.99% complete",
          "multiline": "Task:\n  100% complete"
        },
        "array": [],
        "object": {}
      }
    }
  sample_var_0: '9'
  sample_var_1: |
    [
      "types",
      "number"
      ]
    [
      "types",
      "strings",
      "single"
      ]
    [
      "types",
      "strings",
      "cost"
      ]
    [
      "types",
      "strings",
      "percentage"
      ]
    [
      "types",
      "strings",
      "multiline"
    ]
  sample_var_2: |
    {"types":{"null":null,"boolean":false,"number":123,"strings":{"single":"lorem","cost":"$1.99"}}}
  sample_var_3: |
    {
      "types": {
        "null": null,
        "boolean": false,
        "number": 123,
        "strings": {
          "single": "lorem",
          "cost": "$1.99",
          "percentage": "99.99% complete",
          "multiline": "Task:\n  100% complete"
        },
        "array": [],
        "object": {}
      },
      "array": [
        null,
        false,
        123,
        {
          "single": "lorem",
          "cost": "$1.99",
          "percentage": "99.99% complete",
          "multiline": "Task:\n  100% complete"
        },
        [],
        {}
      ]
    }
jobs:
  # confirm the workflow syntax we will use works
  job-test-workflow-syntax:
    runs-on: ubuntu-latest
    steps:
      - name: Print Env Vars
        run: |
          (
          cat << EOF
          github.actor
          ${{ github.actor }}

          github.event
          ${{ github.event }}

          github.event_name
          ${{ github.event_name }}

          github.githubassets
          ${{ github.githubassets }}

          github.head_ref
          ${{ github.head_ref }}

          github.ref
          ${{ github.ref }}

          github.ref_name
          ${{ github.ref_name }}

          github.repository
          ${{ github.repository }}

          github.run_id
          ${{ github.run_id }}

          github.workflow
          ${{ github.workflow }}

          github.workspace
          ${{ github.workspace }}

          EOF
          );
      - name: Set manual variables
        id: manual-vars
        run: |
          echo "::group::Declare Samples";
          sample_var_0='${{ env.sample_var_0 }}';
          sample_var_1='${{ env.sample_var_1 }}';
          sample_var_2='${{ env.sample_var_2 }}';
          sample_var_3='${{ env.sample_var_3 }}';

          echo "::group::Output Samples";
          (
          cat << EOF_GITHUB_OUTPUT >> $GITHUB_OUTPUT
          sample_var_0<<EOF
          ${sample_var_0}
          EOF
          EOF_GITHUB_OUTPUT
          );

          (
          cat << EOF_GITHUB_OUTPUT >> $GITHUB_OUTPUT
          sample_var_1<<EOF
          ${sample_var_1}
          EOF
          EOF_GITHUB_OUTPUT
          );

          (
          cat << EOF_GITHUB_OUTPUT >> $GITHUB_OUTPUT
          sample_var_2<<EOF
          ${sample_var_2}
          EOF
          EOF_GITHUB_OUTPUT
          );

          (
          cat << EOF_GITHUB_OUTPUT >> $GITHUB_OUTPUT
          sample_var_3<<EOF
          ${sample_var_3}
          EOF
          EOF_GITHUB_OUTPUT
          );

          (
          cat << 'EOF_GITHUB_OUTPUT' >> $GITHUB_OUTPUT
          literal_sample_var<<EOF
          $1.99
          EOF
          EOF_GITHUB_OUTPUT
          );
          echo "::endgroup::";

      - name: Check manual variables
        run: |
          echo "::group::Declare Expectations";
          (
          cat << EOF >/tmp/expected_sample_var_0.txt;
          ${{ env.sample_var_0 }}
          EOF
          );
          (
          cat << EOF >/tmp/expected_sample_var_1.txt;
          ${{ env.sample_var_1 }}
          EOF
          );
          (
          cat << EOF >/tmp/expected_sample_var_2.txt;
          ${{ env.sample_var_2 }}
          EOF
          );
          (
          cat << EOF >/tmp/expected_sample_var_3.txt;
          ${{ env.sample_var_3 }}
          EOF
          );

          literal_sample_var='$1.99'
          (
          cat << EOF >/tmp/expected_literal_sample_var.txt;
          ${literal_sample_var}
          EOF
          );
          echo "::endgroup::";

          echo "::group::Receive results";
          (
          cat << EOF >/tmp/received_sample_var_0.txt
          ${{ steps.manual-vars.outputs.sample_var_0 }}
          EOF
          );
          (
          cat << EOF >/tmp/received_sample_var_1.txt
          ${{ steps.manual-vars.outputs.sample_var_1 }}
          EOF
          );
          (
          cat << EOF >/tmp/received_sample_var_2.txt
          ${{ steps.manual-vars.outputs.sample_var_2 }}
          EOF
          );
          (
          cat << EOF >/tmp/received_sample_var_3.txt
          ${{ steps.manual-vars.outputs.sample_var_3 }}
          EOF
          );
          echo '${{ steps.manual-vars.outputs.literal_sample_var }}' >/tmp/received_literal_sample_var.txt;
          echo "::endgroup::";

          echo "::group::Compare results";
          git diff --no-index /tmp/expected_sample_var_0.txt /tmp/received_sample_var_0.txt && \
          git diff --no-index /tmp/expected_sample_var_1.txt /tmp/received_sample_var_1.txt && \
          git diff --no-index /tmp/expected_sample_var_2.txt /tmp/received_sample_var_2.txt && \
          git diff --no-index /tmp/expected_sample_var_3.txt /tmp/received_sample_var_3.txt && \
          git diff --no-index /tmp/expected_literal_sample_var.txt /tmp/received_literal_sample_var.txt;
          echo "::endgroup::";

  # confirm the docker environment we're creating for the action looks the way we expect it to look
  job-test-env:
    # needs: [job-test-workflow-syntax]
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Commit info
        run: >
          echo "hash=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT;
          echo "name=$(git rev-parse --abbrev-ref HEAD)" >> $GITHUB_OUTPUT;

      - name: Validate entrypoint
        uses: jadutter/jq-action@hotfix/patch-action
        id: valid-entrypoint
        with:
          cmd: |
            if [ ! -f '/entrypoint.sh' ]; then
              echo "::error file=entrypoint.sh,title=Missing entrypoint.sh::entrypoint.sh does not appear to exist!";
              exit 1
            elif [ ! -x '/entrypoint.sh' ]; then
              echo "::error file=entrypoint.sh,title=Unusable entrypoint.sh::entrypoint.sh does not appear to be executable!";
              exit 2
            fi;
            echo "entrypoint.sh appears to be valid"

      - name: Get jq version
        uses: jadutter/jq-action@hotfix/patch-action
        id: get-jq-version
        with:
          cmd: 'jq --version'

      - name: Check jq version
        run: |
          jq_version="$(
            echo "${{ steps.get-jq-version.outputs.stdout }}" | egrep -o 'jq-.+' 
          )";

          if [[ "${#jq_version}" -gt 3 ]]; then
            echo "jq version is '${jq_version}'";
          else
          (
          cat << 'EOF'
          stdout:'${{ steps.get-jq-version.output.stdout }}'
          stderr:'${{ steps.get-jq-version.output.stderr }}'
          exit_code:'${{ steps.get-jq-version.output.exit_code }}'
          EOF
          );
          exit 1;
          fi

      - name: Get git version
        uses: jadutter/jq-action@hotfix/patch-action
        id: get-git-version
        with:
          cmd: 'git --version'

      - name: Check git version
        run: |
          git_version="${{ steps.get-git-version.outputs.stdout }}";

          if [[ "${#git_version}" -gt 3 ]]; then
            echo "git version is '${git_version}'"
          else
          (
          cat << 'EOF'
          stdout:'${{ steps.get-git-version.output.stdout }}'
          stderr:'${{ steps.get-git-version.output.stderr }}'
          exit_code:'${{ steps.get-git-version.output.exit_code }}'
          EOF
          );
          exit 1;
          fi

      - name: Get bash version
        uses: jadutter/jq-action@hotfix/patch-action
        id: get-bash-version
        with:
          cmd: |
            /bin/bash -c 'echo "$(
              echo ${BASH_VERSINFO[@]:0:4} | sed -E "s, +\$,,g;" | tr " " "."
            )$(
              echo ${BASH_VERSINFO[@]:4:2} | sed -E "s, +\$,,g; s,^(.),-\1,g;" |tr " " "-" 
            )";'

      - name: Check bash version
        run: |
          bash_version="${{ steps.get-bash-version.outputs.stdout }}";

          if [[ "${#bash_version}" -gt 3 ]]; then
            echo "bash version is '${bash_version}'"
          else
          (
          cat << 'EOF'
          stdout:'${{ steps.get-bash-version.output.stdout }}'
          stderr:'${{ steps.get-bash-version.output.stderr }}'
          exit_code:'${{ steps.get-bash-version.output.exit_code }}'
          EOF
          );
          exit 1;
          fi

  # confirm the action itself can be used as expected
  job-test-action:
    # needs: [job-test-workflow-syntax, job-test-env]
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      # attempt to use jq in a single line command via jq-action
      - name: Use jq
        uses: jadutter/jq-action@hotfix/patch-action
        id: test-use-jq
        with:
          cmd: 'jq -cn "{foo:\"bar\"} | [.foo]" '

      # confirm the jq-action allows us to access the stderr, stdout, and exit code
      # for the command we executed within the jq-action container
      - name: Check jq usage
        run: |
          (
          cat << 'EOF' >/tmp/expected.txt
          stdout:'["bar"]'
          stderr:''
          exit_code:'0'
          EOF
          );
          (
          cat << 'EOF' >/tmp/received.txt
          stdout:'${{ steps.test-use-jq.outputs.stdout }}'
          stderr:'${{ steps.test-use-jq.outputs.stderr }}'
          exit_code:'${{ steps.test-use-jq.outputs.exit_code }}'
          EOF
          );
          git diff --no-index  /tmp/expected.txt /tmp/received.txt;

      # attempt to pass in a muliline command to be executed in the jq-action
      - name: Use multiline command
        uses: jadutter/jq-action@hotfix/patch-action
        id: test-use-jq-multiline
        with:
          # use YAML folded style for multiline command
          cmd: >
            echo '{"foo":"bar"}' |
            jq '.foo == "bar"'

      # confirm the jq-action allows us to access the stderr, stdout, and exit code
      # for the command we executed within the jq-action container
      - name: Check multiline command
        run: |
          (
          cat << 'EOF' >/tmp/expected.txt
          stdout:'true'
          stderr:''
          exit_code:'0'
          EOF
          );
          (
          cat << 'EOF' >/tmp/received.txt
          stdout:'${{ steps.test-use-jq-multiline.outputs.stdout }}'
          stderr:'${{ steps.test-use-jq-multiline.outputs.stderr }}'
          exit_code:'${{ steps.test-use-jq.outputs.exit_code }}'
          EOF
          );

          git diff --no-index  /tmp/expected.txt /tmp/received.txt;

      # attempt to use jq in a way that would produce an error
      - name: Cause jq
        uses: jadutter/jq-action@hotfix/patch-action
        id: test-cause-jq-error
        continue-on-error: true
        with:
          # we get the value of 'foo', so that returns 'baz';
          # we cannot access the value of 'baz' on a string,
          # so it should throw an error
          cmd: 'jq -cn "{foo:\"bar\"} | [.foo.baz]" '

      # confirm the jq-action allows us to access the stderr, stdout, and exit code
      # for the command we executed within the jq-action container
      - name: Check jq error
        run: |
          cat << 'EOF' >/tmp/expected.txt
          stdout:''
          stderr:'jq: error (at <unknown>): Cannot index string with string "baz"'
          exit_code:'5'
          EOF
          cat << 'EOF' >/tmp/received.txt
          stdout:'${{ steps.test-cause-jq-error.outputs.stdout }}'
          stderr:'${{ steps.test-cause-jq-error.outputs.stderr }}'
          exit_code:'${{ steps.test-cause-jq-error.outputs.exit_code }}'
          EOF
          git diff --no-index  /tmp/expected.txt /tmp/received.txt;

      # attempt to use a multiline command in the jq-action that should
      # return a multiline result
      - name: Use multiline input and output
        uses: jadutter/jq-action@hotfix/patch-action
        id: test-use-jq-multi-input-output
        with:
          cmd: >
            jq -n '${{ env.sample_data }}' |
            jq -r '
                [
                    {
                        types: .types,
                        array: (
                            .types | to_entries | map(.value)
                        )
                    },
                    getpath(["types", "strings", "multiline"])
                ] | .[]
            '

      # confirm we can receive the muliline output we are expecting
      - name: Check multiline input and output
        run: |
          (
          cat << 'EOF' >/tmp/expected.txt
          stdout:'{
            "types": {
              "null": null,
              "boolean": false,
              "number": 123,
              "strings": {
                "single": "lorem",
                "cost": "$1.99",
                "percentage": "99.99% complete",
                "multiline": "Task:\n  100% complete"
              },
              "array": [],
              "object": {}
            },
            "array": [
              null,
              false,
              123,
              {
                "single": "lorem",
                "cost": "$1.99",
                "percentage": "99.99% complete",
                "multiline": "Task:\n  100% complete"
              },
              [],
              {}
            ]
          }
          Task:
            100% complete'
          stderr:''
          exit_code:'0'
          EOF
          );
          (
          cat << 'EOF' >/tmp/received.txt
          stdout:'${{ steps.test-use-jq-multi-input-output.outputs.stdout }}'
          stderr:'${{ steps.test-use-jq-multi-input-output.outputs.stderr }}'
          exit_code:'${{ steps.test-use-jq-multi-input-output.outputs.exit_code }}'
          EOF
          );
          git diff --no-index /tmp/expected.txt /tmp/received.txt;

      # attempt to set arbitary variables within the jq-action container
      - name: Use manual variables
        uses: jadutter/jq-action@hotfix/patch-action
        id: manual-vars-jq
        with:
          cmd: |
            sample_data='${{ env.sample_data }}';
            echo "declared sample_data='${sample_data}'";

            var_0="$( jq -n "${sample_data}" | jq 'paths | length' )";
            echo "declared var_0='${var_0}'";

            (
            cat << EOF_GITHUB_OUTPUT >> $GITHUB_OUTPUT
            var_0<<EOF
            ${var_0}
            EOF
            EOF_GITHUB_OUTPUT
            );
            echo "set var_0";

            var_1="$( jq -n "${sample_data}" | jq 'paths' )";
            echo "declared var_1='${var_1}'";
            (
            cat << EOF_GITHUB_OUTPUT >> $GITHUB_OUTPUT
            var_1<<EOF
            ${var_1}
            EOF
            EOF_GITHUB_OUTPUT
            );
            echo "set var_1";

            var_2="$( jq -n "${sample_data}" | jq 'paths(scalars)' )";
            echo "declared var_2='${var_2}'";
            (
            cat << EOF_GITHUB_OUTPUT >> $GITHUB_OUTPUT
            var_2<<EOF
            ${var_2}
            EOF
            EOF_GITHUB_OUTPUT
            );
            echo "set var_2";

            var_3="$( jq -n "${sample_data}" | jq 'to_entries' )";
            echo "declared var_3='${var_3}'";
            (
            cat << EOF_GITHUB_OUTPUT >> $GITHUB_OUTPUT
            var_3<<EOF
            ${var_3}
            EOF
            EOF_GITHUB_OUTPUT
            );
            echo "set var_3";

            var_4="$( jq -n "${sample_data}" | jq '.' )";
            echo "declared var_4='${var_4}'";
            (
            cat << EOF_GITHUB_OUTPUT >> $GITHUB_OUTPUT
            var_4<<EOF
            ${var_4}
            EOF
            EOF_GITHUB_OUTPUT
            );
            echo "set var_4";

      # Check the output of the manually set variables matches our expectations
      - name: Check manual variables
        run: |
          sample_data='${{ env.sample_data }}';
          echo "declared sample_data='${sample_data}'";

          jq -n "${sample_data}" | jq 'paths | length' >/tmp/expected_var_0.txt;
          jq -n "${sample_data}" | jq 'paths' >/tmp/expected_var_1.txt;
          jq -n "${sample_data}" | jq 'paths(scalars)' >/tmp/expected_var_2.txt;
          jq -n "${sample_data}" | jq 'to_entries' >/tmp/expected_var_3.txt;
          jq -n "${sample_data}" | jq '.' >/tmp/expected_var_4.txt;

          (
          cat << 'EOF' >/tmp/received_var_0.txt
          ${{ steps.manual-vars-jq.outputs.var_0 }}
          EOF
          );
          (
          cat << 'EOF' >/tmp/received_var_1.txt
          ${{ steps.manual-vars-jq.outputs.var_1 }}
          EOF
          );
          (
          cat << 'EOF' >/tmp/received_var_2.txt
          ${{ steps.manual-vars-jq.outputs.var_2 }}
          EOF
          );
          (
          cat << 'EOF' >/tmp/received_var_3.txt
          ${{ steps.manual-vars-jq.outputs.var_3 }}
          EOF
          );
          (
          cat << 'EOF' >/tmp/received_var_4.txt
          ${{ steps.manual-vars-jq.outputs.var_4 }}
          EOF
          );

          git diff --no-index /tmp/expected_var_0.txt /tmp/received_var_0.txt &&
          git diff --no-index /tmp/expected_var_1.txt /tmp/received_var_1.txt &&
          git diff --no-index /tmp/expected_var_2.txt /tmp/received_var_2.txt &&
          git diff --no-index /tmp/expected_var_3.txt /tmp/received_var_3.txt &&
          git diff --no-index /tmp/expected_var_4.txt /tmp/received_var_4.txt;
