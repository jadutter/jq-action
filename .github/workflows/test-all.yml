name: "GitHub-CI: valid image"

on:
  push: {}
  pull_request: {}
  # execute these tests on every branch, to confirm the branch's HEAD can be used as a github action

jobs:
  # confirm we know how to properly escape the data that goes into set-output variables
  job-test-set-output:
    runs-on: ubuntu-latest

    steps:
      - name: Add jq
        id: setup-vanilla-ubuntu
        run: 'apt-get update && apt-get install jq && echo "Added jq"'

      - name: Manually set-output variables
        id: manual-vars
        run: >
          sed_command='
              :nextLine;
              {
                  # add the next line to the pattern space
                  N;
              }
              # if not the end of the file
              $!{
                  # grab another line
                  b nextLine;
              }
              # esape newline characters
              s/\n/%0A/g;
              s/\r/%0D/g;
              # escape characters that would interfere with the `echo ":::set-output...`
              s/("|\\|\$)/\\\1/g;
              # escape percentage sign
              s/%/%25/g;
              # escape whitespace 
              s/  /%09/g;
              s/ /%20/g;
            ';
          echo "declared sed_command";

          var0="9";
          echo "declared var0";
          var1='[\n  "types",\n  "number"\n]\n[\n  "types",\n  "strings",\n  "single"\n]\n[\n  "types",\n  "strings",\n  "cost"\n]\n[\n  "types",\n  "strings",\n  "percentage"\n]\n[\n  "types",\n  "strings",\n  "multiline"\n]';
          echo "declared var1";
          var2='[\n  {\n    "key": "null",\n    "value": null\n  },\n  {\n    "key": "boolean",\n    "value": false\n  },\n  {\n    "key": "number",\n    "value": 123\n  },\n  {\n    "key": "array",\n    "value": []\n  },\n  {\n    "key": "object",\n    "value": {}\n  }\n]';
          echo "declared var2";
          var3="{\"types\":{\"null\":null,\"boolean\":false,\"number\":123,\"strings\":{\"single\":\"lorem\",\"cost\":\"$1.99\",\"percentage\":\"99.99% complete\",\"multiline\":\"Task:\\n\\t100% complete\"},\"array\":[],\"object\":{}}}";
          echo "declared var3";
          echo "::set-output name=var0::$(echo "${var0}" | sed -E "${sed_command}")";
          echo "set var0";
          echo "::set-output name=var1::$(echo "${var1}" | sed -E "${sed_command}")";
          echo "set var1";
          echo "::set-output name=var2::$(echo "${var2}" | sed -E "${sed_command}")";
          echo "set var2";
          echo "::set-output name=var3::$(echo "${var3}" | sed -E "${sed_command}")";
          echo "set var3";

      - name: Check manual set-output
        run: >
          data='{
              "types": {
                "null": null,
                "boolean": false,
                "number": 123,
                "strings": {
                  "single": "lorem",
                  "cost": "$1.99",
                  "percentage": "99.99% complete",
                  "multiline": "Task:\n\t100% complete"
                },
                "array": [],
                "object": {}
              }
            }';
          var0="9";
          echo "declared var0";
          var1='[\n  "types",\n  "number"\n]\n[\n  "types",\n  "strings",\n  "single"\n]\n[\n  "types",\n  "strings",\n  "cost"\n]\n[\n  "types",\n  "strings",\n  "percentage"\n]\n[\n  "types",\n  "strings",\n  "multiline"\n]';
          echo "declared var1";
          var2='[\n  {\n    "key": "null",\n    "value": null\n  },\n  {\n    "key": "boolean",\n    "value": false\n  },\n  {\n    "key": "number",\n    "value": 123\n  },\n  {\n    "key": "array",\n    "value": []\n  },\n  {\n    "key": "object",\n    "value": {}\n  }\n]';
          echo "declared var2";
          var3="{\"types\":{\"null\":null,\"boolean\":false,\"number\":123,\"strings\":{\"single\":\"lorem\",\"cost\":\"$1.99\",\"percentage\":\"99.99% complete\",\"multiline\":\"Task:\\n\\t100% complete\"},\"array\":[],\"object\":{}}}";
          echo "declared var3";
          if [[ "${{ steps.manual-vars.outputs.var0 }}" != "${var0}" ]]; then 
            echo "var0:\n\texpected:'${var0}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var0 }}'"
            exit 1
          elif [[ "${{ steps.manual-vars.outputs.var1 }}" != "${var1}" ]]; then 
            echo "var1:\n\texpected:'${var1}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var1 }}'"
            exit 1
          elif [[ "${{ steps.manual-vars.outputs.var2 }}" != "${var2}" ]]; then 
            echo "var2:\n\texpected:'${var2}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var2 }}'"
            exit 1
          elif [[ "${{ steps.manual-vars.outputs.var3 }}" != "${var3}" ]]; then 
            echo "var3:\n\texpected:'${var3}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var3 }}'"
            exit 1
          fi;

  # confirm the docker environment we're creating for the action looks the way we expect it to look
  job-test-env:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Commit info
        run: >
          echo "::set-output hash=var2::$(git rev-parse HEAD)";
          echo "::set-output name=var2::$(git rev-parse --abbrev-ref HEAD)";

      - name: Validate entrypoint
        uses: jadutter/jq-action@test-workflows
        id: valid-entrypoint
        with:
          cmd: >
            if [ ! -f '/entrypoint.sh' ]; then
              echo "forgot to add entrypoint.sh" >&2
              exit 1
            elif [ ! -x '/entrypoint.sh' ]; then
              echo "forgot to make entrypoint.sh executable" >&2
              exit 2
            fi;
            echo "entrypoint is valid"

      - name: Get jq version
        uses: jadutter/jq-action@test-workflows
        id: version
        with:
          cmd: "jq --version"

      - name: Check version
        run: >
          jq_version="$(echo "${{ steps.version.outputs.stdout }}" | egrep -o 'jq-.+' )";
          if [[ "${#jq_version}" -gt 3 ]]; then 
            echo "jq version is '${jq_version}'"
          else
            echo "stdout:"
            echo "${{ steps.version.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.version.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.version.outputs.exit_code }}"
            exit 1
          fi

  # confirm the action itself can be used as expected
  job-test-action:
    needs: [job-test-set-output, job-test-env]
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: use jq
        uses: jadutter/jq-action@test-workflows
        id: test-use-jq
        with:
          cmd: 'jq -cn "{foo:\"bar\"} | [.foo]" '

      - name: Check usage
        run: >
          if [[ ! "${{ steps.test-use-jq.outputs.stdout }}" == "[\"bar\"]" ]]; then 
            echo "stdout:"
            echo "${{ steps.test-use-jq.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.test-use-jq.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.test-use-jq.outputs.exit_code }}"
            exit 1
          fi

      - name: multi-line command
        uses: jadutter/jq-action@test-workflows
        id: test-use-jq-multi-line
        with:
          # use YAML folded style for multi-line command
          cmd: >
            echo '{"foo":"bar"}' | 
            jq '.foo == "bar"'

      - name: Check multiline usage
        run: >
          if [[ "${{ steps.test-use-jq-multi-line.outputs.stdout }}" != "true" ]]; then 
            echo "stdout:"
            echo "${{ steps.test-use-jq-multi-line.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.test-use-jq-multi-line.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.test-use-jq-multi-line.outputs.exit_code }}"
            exit 1
          fi

      - name: multi-line input and output
        uses: jadutter/jq-action@test-workflows
        id: test-use-jq-multi-line-output
        with:
          cmd: >
            jq -n '{
              types: {
                null: null,
                boolean: false,
                number: 123,
                strings: {
                  single: "lorem",
                  cost: "$1.99",
                  percentage: "99.99% complete",
                  multiline: "Task:\n\t100% complete"
                },
                array: [],
                object: {}
              }
            }' | 
            jq -r '
                [
                    {
                        types: .types,
                        array: (
                            .types | to_entries | map(.value)
                        )
                    },
                    getpath(["types", "strings", "multiline"])
                ] | .[]
            '

      - name: Check multiline input and output usage
        run: >
          expect='{\n  "types": {\n    "null": null,\n    "boolean": false,\n    "number": 123,\n    "strings": {\n      "single": "lorem",\n      "cost": "$1.99",\n      "percentage": "99.99% complete",\n      "multiline": "Task:\n\t100% complete"\n    },\n    "array": [],\n    "object": {}\n  },\n  "array": [\n    null,\n    false,\n    123,\n    {\n      "single": "lorem",\n      "cost": "$1.99",\n      "percentage": "99.99% complete",\n      "multiline": "Task:\\n\\t100% complete"\n    },\n    [],\n    {}\n  ]\n}\nTask:\n\tt100% complete';
          if [[ "${{ steps.test-use-jq-multi-line-output.outputs.stdout }}" != "$expect" ]]; then 
            echo "stdout:"
            echo "${{ steps.test-use-jq-multi-line-output.outputs.stdout }}"
            echo "stderr:"
            echo "${{ steps.test-use-jq-multi-line-output.outputs.stderr }}"
            echo "exit_code:"
            echo "${{ steps.test-use-jq-multi-line-output.outputs.exit_code }}"
            exit 1
          fi

      - name: Manually set-output variables
      - uses: jadutter/jq-action@test-workflows
        id: manual-vars-jq
        run: >
          data='{
                "types": {
                  "null": null,
                  "boolean": false,
                  "number": 123,
                  "strings": {
                    "single": "lorem",
                    "cost": "$1.99",
                    "percentage": "99.99% complete",
                    "multiline": "Task:\n\t100% complete"
                  },
                  "array": [],
                  "object": {}
                }
              }';
          echo "declared data";
          sed_command='
              :nextLine;
              {
                  # add the next line to the pattern space
                  N;
              }
              # if not the end of the file
              $!{
                  # grab another line
                  b nextLine;
              }
              # esape newline characters
              s/\n/%0A/g;
              s/\r/%0D/g;
              # escape characters that would interfere with the `echo ":::set-output...`
              s/("|\\|\$)/\\\1/g;
              # escape percentage sign
              s/%/%25/g;
              # escape whitespace 
              s/  /%09/g;
              s/ /%20/g;
            ';
          echo "declared sed_command";
          var0="$(echo "${data}" | jq 'paths | length' )";
          echo "declared var0";
          var1="$(echo "${data}" | jq 'paths' )";
          echo "declared var1";
          var2="$(echo "${data}" | jq 'paths(scalars)' )";
          echo "declared var2";
          var3="$(echo "${data}" | jq 'to_entries' )";
          echo "declared var3";
          var4="$(echo "${data}" | jq '.' )";
          echo "declared var4";
          echo "::set-output name=var0::$(echo "${var0}" | sed -E "${sed_command}")";
          echo "set var0";
          echo "::set-output name=var1::$(echo "${var1}" | sed -E "${sed_command}")";
          echo "set var1";
          echo "::set-output name=var2::$(echo "${var2}" | sed -E "${sed_command}")";
          echo "set var2";
          echo "::set-output name=var3::$(echo "${var3}" | sed -E "${sed_command}")";
          echo "set var3";
          echo "::set-output name=var4::$(echo "${var4}" | sed -E "${sed_command}")";
          echo "set var4";

      - name: Check manual set-output
      - uses: jadutter/jq-action@test-workflows
        run: >
          data='{
              "types": {
                "null": null,
                "boolean": false,
                "number": 123,
                "strings": {
                  "single": "lorem",
                  "cost": "$1.99",
                  "percentage": "99.99% complete",
                  "multiline": "Task:\n\t100% complete"
                },
                "array": [],
                "object": {}
              }
            }';
          echo "declared data";
          var0="$(echo "${data}" | jq 'paths | length' )";
          echo "declared var0";
          var1="$(echo "${data}" | jq 'paths' )";
          echo "declared var1";
          var2="$(echo "${data}" | jq 'paths(scalars)' )";
          echo "declared var2";
          var3="$(echo "${data}" | jq 'to_entries' )";
          echo "declared var3";
          var4="$(echo "${data}" | jq '.' )";
          echo "declared var4";
          if [[ "${{ steps.manual-vars-jq.outputs.var0 }}" != "${var0}" ]]; then 
            echo "var0:\n\texpected:'${var0}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var0 }}'"
            exit 1
          elif [[ "${{ steps.manual-vars-jq.outputs.var1 }}" != "${var1}" ]]; then 
            echo "var1:\n\texpected:'${var1}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var1 }}'"
            exit 1
          elif [[ "${{ steps.manual-vars-jq.outputs.var2 }}" != "${var2}" ]]; then 
            echo "var2:\n\texpected:'${var2}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var2 }}'"
            exit 1
          elif [[ "${{ steps.manual-vars-jq.outputs.var3 }}" != "${var3}" ]]; then 
            echo "var3:\n\texpected:'${var3}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var3 }}'"
            exit 1
          elif [[ "${{ steps.manual-vars-jq.outputs.var4 }}" != "${var4}" ]]; then 
            echo "var4:\n\texpected:'${var4}'\n\treceived:'${{ steps.test-use-jq-multi-line.outputs.var4 }}'"
            exit 1
          fi;
